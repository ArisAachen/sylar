## 简单报错
1. undefined reference to xxx     
出现此问题是由于 模板的实现 不能放在 .cc 文件中, 仅能放在 .h 文件， 
如下 signal 成员函数必须实现在 .h 文件中 
``` cpp
template<typename T>
class ConditionImpl {
public:
    void signal();
}
```

2. 智能指针 received signal SIGSEGV, Segmentation fault  (最新已确认非问题, 但是不建议在全局变量中使用 shared_ptr)
只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，  
编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。

3. Fiber::main_func 造成coredump  
由于协程栈分配太小, 导致 cb_ 丢失了, 如下 cb_ 由于栈太小丢失了  
``` cpp  
    // fiber.cc 
void Fiber::main_func() {
    if (fiber->cb_)
        fiber->cb_();
}
```


4. Fiber::ptr idle_fiber(new Fiber(std::bind(&Scheduler::idle, this), 0, false, "idle")) 
放在外面 导致进程退出了 

5. Call to non-static member function without an object argument   
成员函数定义为非静态, 但是调用却用了静态的 :: 

6. list中pop成员, 导致了coredump   
由于 condition variant 中, 当两个线程调用 wait 时, 错误处理逻辑   
导致其中一个线程未成功 wait, 获取了 list 中的空值, 导致了 coredump, 
如下, 应该允许重复 wait 
``` cpp
void ConditionBlock::wait() { 
    // already has one block
    if (blocked_) 
        return;    
}
```

7. enum class Type 导致的报错   
形如 Type xxx = Type::Exsaple1 | Type::Exsample2 是不合法的   
需要转化成 int 
``` cpp
// iomanager
IOManager::Event IOManager::FdContext::get_events() {
    Event events;
    for (auto& item : dispatcher)
        events |= item.first;
}
```

8. called after throwing an instance of 'std::bad_weak_ptr'  
参考文档: https://www.jianshu.com/p/1719f83cbd85 
错误原因是在成员函数中, 使用了 shared_from_this(), 但是该对象在被创造时, 不是使用 shared_ptr 
``` cpp
// main.cc
void io_manager_test() {
    sylar::IOManager* manager = new sylar::IOManager(1, false, "IO Manager");
}

// iomanager.cc
void IOManager::add_fd_event(int fd, Event event, std::function<void ()> cb) {
    ctx->add_event(event, shared_from_this(), cb);
}
```

9. 使用 iomanager 时, start() 函数期待阻塞, 但实际情况并未被阻塞,  
阻塞是由于 在 Scheduler 的析构函数中, 对 thread 采用了 wait,  
未阻塞的原因是由于 Scheduler 的析构函数未被调用, 根本原因是 shared_ptr 引用循环了 
``` cpp
// iomanager.cc
struct EventContext {
    Scheduler::ptr scheduler;
}

// iomanager.cc 

```